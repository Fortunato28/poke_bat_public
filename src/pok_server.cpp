// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "pok_server.h"
#include "gen-cpp/PokServer.h"
#include "fight.h"
#include "server_config_handler.h"
#include "conf.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::poke_bat::middleware;
using namespace work_with_datbase;

PokServerHandler::PokServerHandler() 
    : next_fight_id_(0),
      dbManager_(host, user, pass, db)
{
}

Fight& PokServerHandler::findFight(const int64_t &fight_id)
{
    //printf("%lu", fight_storage.find(fight_id)->first);
    return fight_storage_.at(fight_id);
}

void PokServerHandler::getConfig(std::string& _return)
{
    serverConfigHandler configHandler;
    _return = configHandler.EncryptConfig();
}

void PokServerHandler::startFight(FightData& _return, const int64_t complexity, const Pokemon& clientPokemon)
{
  _return.pokemon = dbManager_.GetPokemon(complexity);
  Fight fight(clientPokemon, _return.pokemon);
  fight_storage_.emplace(next_fight_id_, fight);

  printf("HERE GOTTEN POKEMON%ld\n", _return.pokemon.LVL);

  _return.__set_fight_id(next_fight_id_);
  ++next_fight_id_;
}

int64_t calculateDamage(int64_t lvl, int64_t attack, int64_t def)
{
    return ((((2 * lvl / 5) + 2) * (attack / def) / 50) + 2);
}

std::string clientWin()
{
    printf("HERE %s\n", "client is win");

    return {"Congratulations!\n"
            "You won the battle!\n"
            "You earn some EXP!\n"};
}

std::string serverWin()
{
    printf("HERE %s\n", "server is win");

    return {"Try harder nex time, loser!\n"
            "You lost the battle!\n"
            "Your pokemon is dead inside!\n"};
}

bool isDeadInside(const Pokemon& pok)
{
    return pok.HP <= 0 ? true : false;
}

bool PokServerHandler::isFightStopped(
        RoundResult& roundResult_,
        const Pokemon& s_pok,
        const Pokemon& c_pok,
        const int64_t fight_id)
{
    if(isDeadInside(s_pok))
    {
        //TODO calculate exp according to s_pok level
        //c_pok.EXP += 100;

        roundResult_.__set_clientPokemon(c_pok);
        roundResult_.__set_serverPokemon(s_pok);
        roundResult_.__set_actionResultDescription(clientWin());
        // Drop fight
        fight_storage_.erase(fight_id);
        return true;
    }
    if(isDeadInside(c_pok))
    {
        roundResult_.__set_clientPokemon(c_pok);
        roundResult_.__set_serverPokemon(s_pok);
        roundResult_.__set_actionResultDescription(serverWin());
        // Drop fight
        fight_storage_.erase(fight_id);
        return true;
    }

    return false;
}

void PokServerHandler::punch(RoundResult& _return, const int64_t fight_id)
{
    Fight& current_fight = findFight(fight_id);
    // Extract pokemons from fight object
    auto& c_pok = current_fight.client_pokemon_;
    auto& s_pok = current_fight.server_pokemon_;

    // Calculate damage
    auto lvl = c_pok.LVL;
    auto attack = c_pok.attack;
    auto def = s_pok.defense;
    int64_t damage = calculateDamage(lvl, attack, def);

    // Apply damage to server_pokemon
    printf("BEFORE punch %ld\n", s_pok.HP);
    printf("DAMAGE %ld\n", damage);
    s_pok.HP -= damage;
    printf("AFTER punch %ld\n", s_pok.HP);

    if(isFightStopped(_return, s_pok, c_pok, fight_id))
    {
        return;
    }

    _return.__set_clientPokemon(c_pok);
    _return.__set_serverPokemon(s_pok);
}

void PokServerHandler::defend(RoundResult& _return, const int64_t fight_id)
{
  // Your implementation goes here
  findFight(fight_id);
  printf("defend\n");
}

void PokServerHandler::useSkill(RoundResult& _return, const int64_t fight_id, const std::string& skillName)
{
  // Your implementation goes here
  findFight(fight_id);
  printf("useSkill\n");
}
