// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "pok_server.h"
#include "gen-cpp/PokServer.h"
#include "fight.h"
#include "server_config_handler.h"
#include "conf.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::poke_bat::middleware;
using namespace work_with_datbase;

PokServerHandler::PokServerHandler() 
    : next_fight_id_(0),
      dbManager_(host, user, pass, db)
{
}

Fight& PokServerHandler::findFight(const int64_t &fight_id)
{
    //printf("%lu", fight_storage.find(fight_id)->first);
    return fight_storage_.at(fight_id);
}

void PokServerHandler::getConfig(std::string& _return)
{
    serverConfigHandler configHandler;
    _return = configHandler.EncryptConfig();
}

void PokServerHandler::startFight(FightData& _return, const int64_t complexity, const Pokemon& clientPokemon)
{
  _return.pokemon = dbManager_.GetPokemon(complexity);
  Fight fight(clientPokemon, _return.pokemon);
  fight_storage_.emplace(next_fight_id_, fight);

  printf("HERE GOTTEN POKEMON%ld\n", _return.pokemon.LVL);

  _return.__set_fight_id(next_fight_id_);
  ++next_fight_id_;
}

std::string clientWin()
{
    printf("HERE %s\n", "client is win");

    return {"Congratulations!\n"
            "You won the battle!\n"
            "You earn some EXP!\n"};
}

std::string serverWin()
{
    printf("HERE %s\n", "server is win");

    return {"Try harder nex time, loser!\n"
            "You lost the battle!\n"
            "Your pokemon is dead inside!\n"};
}

bool isDeadInside(const Pokemon& pok)
{
    return pok.HP <= 0 ? true : false;
}

bool PokServerHandler::isFightStopped(
        RoundResult& roundResult_,
        const Pokemon& s_pok,
        const Pokemon& c_pok,
        const int64_t fight_id)
{
    if(isDeadInside(s_pok))
    {
        //TODO calculate exp according to s_pok level
        //c_pok.EXP += 100;

        roundResult_.__set_clientPokemon(c_pok);
        roundResult_.__set_serverPokemon(s_pok);
        roundResult_.__set_actionResultDescription(clientWin());
        // Drop fight
        fight_storage_.erase(fight_id);
        return true;
    }
    if(isDeadInside(c_pok))
    {
        roundResult_.__set_clientPokemon(c_pok);
        roundResult_.__set_serverPokemon(s_pok);
        roundResult_.__set_actionResultDescription(serverWin());
        // Drop fight
        fight_storage_.erase(fight_id);
        return true;
    }

    return false;
}

void PokServerHandler::punch(RoundResult& _return, const int64_t fight_id)
{
    Fight& current_fight = findFight(fight_id);

    // For an appropriate handling of the client pokemon's state
    current_fight.handleClientStats();

    // Extract pokemons from fight object
    auto& c_pok = current_fight.getClientPok();
    auto& s_pok = current_fight.getServerPok();

    current_fight.decreaseServerHPDueToPunch();

    if(isFightStopped(_return, s_pok, c_pok, fight_id))
    {
        return;
    }

    // TODO Добавить возврат строки с описание произешедшего за раунд
    _return.__set_clientPokemon(c_pok);
    _return.__set_serverPokemon(s_pok);
}

void PokServerHandler::defend(RoundResult& _return, const int64_t fight_id)
{
    Fight& current_fight = findFight(fight_id);

    // For an appropriate handling of the client pokemon's state
    current_fight.handleClientStats();

    // Extract pokemons from fight object
    auto& c_pok = current_fight.getClientPok();
    auto& s_pok = current_fight.getServerPok();

    current_fight.setClientDefense();

    // TODO Добавить возврат строки с описание произешедшего за раунд
    _return.__set_clientPokemon(c_pok);
    _return.__set_serverPokemon(s_pok);
}

void PokServerHandler::useSkill(RoundResult& _return, const int64_t fight_id, const std::string& skillName)
{
    Fight& current_fight = findFight(fight_id);

    // For an appropriate handling of the client pokemon's state
    current_fight.handleClientStats();

    // Extract pokemons from fight object
    auto& c_pok = current_fight.getClientPok();
    auto& s_pok = current_fight.getServerPok();

    const PokemonSkill& c_skill = c_pok.skill;
    if(c_skill.amount < 0)
    {
        _return.__set_actionResultDescription("Your pokemon cunt use skills anymore!\n"
                                               "You`ve just screwed up your turn ┌∩┐(◣_◢)┌∩┐");
        _return.__set_clientPokemon(c_pok);
        _return.__set_serverPokemon(s_pok);
    }

    // TODO Не забыть в кейзах прописать нарезку результирующей строки с описанием раунда
    // Depends on skill type
        printf("BEFORE SKILL %ld\n", c_pok.attack);
        // TODO delete
        c_pok.skill.type = SkillType::BUFF;
        c_pok.spell_attack = 100;
    switch(c_skill.type)
    {
        case SkillType::BUFF:
            // Buff client pok
            current_fight.setClientBuf();
            break;
        case SkillType::DEBUFF:
            // Debuff server pok
            current_fight.setServerDebuf();
            break;
        case SkillType::ATTACK:
            // Decrease server pok HP
            current_fight.decreaseServerHPDueToSkill();
            break;
    }
        printf("AFTER SKILL %ld\n", c_pok.attack);

    _return.__set_clientPokemon(c_pok);
    _return.__set_serverPokemon(s_pok);
}
